## @ GenNCCfgData.py
#
# Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: BSD-2-Clause-Patent
#
##

import os
import sys
import re
import struct
import marshal
import pprint
import string
import operator as op
import ast
import binascii
from   datetime    import date
from   collections import OrderedDict
from tokenize import Double
import xml.etree.ElementTree as ET
import xmlschema

from CommonUtility import *
from VariableList import Schema, IntValueFormat, FloatValueFormat, BoolFormat, EnumFormat, StructFormat, ArrayFormat

# Generated file copyright header
__copyright_tmp__ = """/** @file

  Platform Configuration %s File.

  Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
  Copyright (c) Microsoft Corporation.
  SPDX-License-Identifier: BSD-2-Clause-Patent

  This file is automatically generated. Please do NOT modify !!!

**/
"""

def get_copyright_header (file_type, allow_modify = False):
    file_description = {
        'yaml': 'Boot Setting',
        'dlt' : 'Delta',
        'inc' : 'C Binary Blob',
        'h'   : 'C Struct Header'
    }
    if file_type in ['yaml', 'dlt']:
        comment_char = '#'
    else:
        comment_char = ''
    lines = __copyright_tmp__.split('\n')
    if allow_modify:
      lines = [line for line in lines if 'Please do NOT modify' not in line]
    copyright_hdr = '\n'.join('%s%s' % (comment_char, line) for line in lines)[:-1] + '\n'
    return copyright_hdr % (file_description[file_type], date.today().year)

def check_quote (text):
    if (text[0] == "'" and text[-1] == "'") or (text[0] == '"' and text[-1] == '"'):
        return True
    return False

def strip_quote (text):
    new_text = text.strip()
    if check_quote (new_text):
        return new_text[1:-1]
    return text

def strip_delimiter (text, delim):
    new_text = text.strip()
    if new_text:
        if new_text[0] == delim[0] and new_text[-1] == delim[-1]:
            return new_text[1:-1]
    return text

def bytes_to_bracket_str (bytes):
    return '{ %s }' % (', '.join('0x%02x' % i for i in bytes))

def array_str_to_value (val_str):
    val_str = val_str.strip()
    val_str = strip_delimiter (val_str, '{}')
    val_str = strip_quote (val_str)
    value = 0
    for each in val_str.split(',')[::-1]:
        each = each.strip()
        value = (value << 8) | int(each, 0)
    return value

def write_lines (lines, file):
    fo = open(file, "w")
    fo.write (''.join ([x[0] for x in lines]))
    fo.close ()

def read_lines (file):
    if not os.path.exists(file):
        test_file = os.path.basename(file)
        if os.path.exists(test_file):
            file = test_file
    fi = open (file, 'r')
    lines = fi.readlines ()
    fi.close ()
    return lines

def expand_file_value (path, value_str):
    result = bytearray()
    match  = re.match("\{\s*FILE:(.+)\}", value_str)
    if match:
        file_list = match.group(1).split(',')
        for file in file_list:
            file = file.strip()
            bin_path = os.path.join(path, file)
            result.extend(bytearray(open(bin_path, 'rb').read()))
    return result


class DefTemplate(string.Template):
    idpattern = '\([_A-Z][_A-Z0-9]*\)|[_A-Z][_A-Z0-9]*'


class CGenNCCfgData:
    STRUCT         = '$STRUCT'
    bits_width     = {'b':1, 'B':8, 'W':16, 'D':32, 'Q':64}
    builtin_option = {'$EN_DIS' : [('0', 'Disable'), ('1', 'Enable')]}
    exclude_struct = ['Enums']
    include_tag    = ['GPIO_CFG_DATA']
    keyword_set    = set(['name', 'type', 'default', 'help', 'deprecated', 'enumtype'])
    config_list    = ['KNOBS']
    peripheral_list= ['ENUMS']

    def __init__(self):
        self.initialize ()


    def initialize (self):
        self._cfg_tree  = {}
        self._tmp_tree  = {}
        self._cfg_list  = []
        self._cfg_page  = {'root': {'title': '', 'child': []}}
        self._cur_page  = 'Non-core'
        self._cfg_page['root']['child'].append ({self._cur_page: {'title': self._cur_page, 'child': []}})
        self._var_dict  = {}
        self._def_dict  = {}


    @staticmethod
    def deep_convert_dict (layer):
        # convert OrderedDict to list + dict
        new_list = layer
        if isinstance(layer, OrderedDict):
            new_list = list (layer.items())
            for idx, pair in enumerate (new_list):
                new_node = CGenNCCfgData.deep_convert_dict (pair[1])
                new_list[idx] = dict({pair[0] : new_node})
        return new_list


    @staticmethod
    def deep_convert_list (layer):
        if isinstance(layer, list):
            od = OrderedDict({})
            for each in layer:
                if isinstance(each, dict):
                    key = next(iter(each))
                    od[key] = CGenNCCfgData.deep_convert_list(each[key])
            return od
        else:
            return layer


    @staticmethod
    def expand_include_files (file_path, cur_dir = ''):
        if cur_dir == '':
            cur_dir   = os.path.dirname(file_path)
            file_path = os.path.basename(file_path)

        input_file_path = os.path.join(cur_dir, file_path)
        file  = open(input_file_path, "r")
        lines = file.readlines()
        file.close()

        new_lines = []
        for line_num, line in enumerate(lines):
            match = re.match("^!include\s*(.+)?$", line.strip())
            if match:
                inc_path = match.group(1)
                tmp_path = os.path.join(cur_dir, inc_path)
                org_path = tmp_path
                if not os.path.exists(tmp_path):
                    cur_dir = os.path.join(os.path.dirname (os.path.realpath(__file__)), "..", "..")
                tmp_path = os.path.join(cur_dir, inc_path)
                if not os.path.exists(tmp_path):
                    raise Exception ("ERROR: Cannot open include file '%s'." % org_path)
                else:
                    new_lines.append (('# Included from file: %s\n' % inc_path, tmp_path, 0))
                    new_lines.append (('# %s\n' % ('=' * 80), tmp_path, 0))
                    new_lines.extend (CGenNCCfgData.expand_include_files (inc_path, cur_dir))
            else:
                new_lines.append ((line, input_file_path, line_num))

        return new_lines


    @staticmethod
    def format_struct_field_name (input, count = 0):
        name = ''
        cap  = True
        if '_' in input:
            input = input.lower()
        for each in input:
          if each == '_':
              cap = True
              continue
          elif cap:
              each = each.upper()
              cap  = False
          name = name + each

        if count > 1:
            name = '%s[%d]' % (name, count)

        return name

    def get_last_error (self):
        return ''


    def get_variable (self, var, attr = 'value'):
        if var in self._var_dict:
            var = self._var_dict[var]
            return var

        item = self.locate_cfg_item (var, False)
        if item is None:
            raise ValueError ("Cannot find variable '%s' !" % var)

        if item:
            if 'indx' in item:
                item = self.get_item_by_index (item['indx'])
            if attr == 'offset':
                var  = item['offset']
            elif attr == 'length':
                var  = item['length']
            elif attr == 'value':
                var  = self.get_cfg_item_value (item)
            else:
                raise ValueError ("Unsupported variable attribute '%s' !" % attr)
        return var


    def eval (self, expr):
        def _handler (pattern):
            if pattern.group(1):
                target = 1
            else:
                target = 2
            result = self.get_variable(pattern.group(target))
            if result is None:
                raise ValueError('Unknown variable $(%s) !' % pattern.group(target))
            return hex(result)

        expr_eval = ExpressionEval ()
        if '$' in expr:
            # replace known variable first
            expr = re.sub(r'\$\(([_a-zA-Z][\w\.]*)\)|\$([_a-zA-Z][\w\.]*)', _handler, expr)
        return expr_eval.eval(expr, self.get_variable)


    def get_cfg_list (self, page_id = None):
        if page_id is None:
            # return full list
            return self.knob_shim
        else:
            # build a new list for items under a page ID
            cfgs =  [i for i in self.knob_shim if ('.'.join(i['path'].split('.')[:2]) == page_id)]
            return cfgs

    def get_cfg_page (self):
        return self._cfg_page

    def get_cfg_item_length (self, item):
        return item['inst'].format.size_in_bytes()

    def get_cfg_item_value (self, item, array = False):
        length = item['inst'].format.size_in_bytes()
        return  self.get_value (item, length, array)

    def format_value_to_str (self, value, bit_length, old_value = '', item=None):
        if item != None:
            obj = item['inst'].format.binary_to_object (value)
            return item['inst'].format.object_to_string(obj)
        else:
            raise Exception ("Cannot accept item being None for xml parser!!!")


    def reformat_value_str (self, value_str, bit_length, old_value = None, item=None):
        if item == None:
            raise Exception ("Cannot accept item being None for xml parser!!!")
        obj = item['inst'].format.string_to_object (value_str)
        new_value = item['inst'].format.object_to_string (obj)
        return new_value


    def get_value (self, item, bit_length, array = True, value_str = None):
        if value_str == None:
            value_str = item['value'].strip()
        data_inst = item['inst']
        if len(value_str) == 0:
            return 0
        obj = data_inst.format.string_to_object (value_str)
        bvalue = data_inst.format.object_to_binary (obj)
        if array:
            return  bvalue
        else:
            return  bytes_to_value (bvalue)


    def parse_value (self, value_str, bit_length, array = True, item=None):
        return self.get_value(item, bit_length, array, value_str)

    def get_cfg_item_options (self, item):
        tmp_list = []
        if  item['type'].upper() == "ENUM_KNOB":
            if type(item['inst'].format) is not EnumFormat:
                raise Exception ("The item is malformatted!!!")
            tmp_list = [i.name for i in item['inst'].format.values]
        elif item['type'].upper() == "BOOL_KNOB":
            if type(item['inst'].format) is not BoolFormat:
                raise Exception ("The item is malformatted!!!")
            tmp_list = ['True', 'False']
        return  tmp_list

    def get_page_title(self, page_id, top = None):
        if top is None:
            top = self.get_cfg_page()['root']
        for node in top['child']:
            page_key = next(iter(node))
            if page_id == page_key:
                return node[page_key]['title']
            else:
                result = self.get_page_title (page_id, node[page_key])
                if result is not None:
                    return result
        return None


    def print_pages(self, top=None, level=0):
        if top is None:
            top = self.get_cfg_page()['root']
        for node in top['child']:
            page_id = next(iter(node))
            print('%s%s: %s' % ('  ' * level, page_id, node[page_id]['title']))
            level += 1
            self.print_pages(node[page_id], level)
            level -= 1


    def get_item_by_index (self, index):
        return self._cfg_list[index]


    def get_item_by_path (self, path):
        for each in self.knob_shim:
            if each['inst'].name == path:
                return each
        return None

    def locate_cfg_path (self, item):
        def _locate_cfg_path (root, level = 0):
            # config structure
            if item is root:
                return path
            for key in root:
                if type(root[key]) is OrderedDict:
                    level += 1
                    path.append(key)
                    ret = _locate_cfg_path (root[key], level)
                    if ret:
                        return ret
                    path.pop()
            return None
        path = []
        return _locate_cfg_path (self._cfg_tree)


    def locate_cfg_item (self, path, allow_exp = True):
        def _locate_cfg_item (root, path, level = 0):
            if len(path) == level:
                return root
            next_root = root.get(path[level], None)
            if next_root is None:
                if allow_exp:
                    raise Exception ('Not a valid CFG config option path: %s' % '.'.join(path[:level+1]))
                else:
                    return None
            return _locate_cfg_item (next_root, path, level + 1)

        path_nodes = path.split('.')
        return _locate_cfg_item (self._cfg_tree, path_nodes)


    def traverse_cfg_tree (self, handler, top = None):
        def _traverse_cfg_tree (root, level = 0):
            # config structure
            for key in root:
                if type(root[key]) is OrderedDict:
                    level += 1
                    handler (key, root[key], level)
                    _traverse_cfg_tree (root[key], level)
                    level -= 1

        if top is None:
            top = self._cfg_tree
        _traverse_cfg_tree (top)


    def add_cfg_page(self, child, parent='Non-core', title=''):
        def _add_cfg_page(cfg_page, child, parent):
            key = next(iter(cfg_page))
            if parent == key:
                cfg_page[key]['child'].append({child: {'title': title,
                                                       'child': []}})
                return True
            else:
                result = False
                for each in cfg_page[key]['child']:
                    if _add_cfg_page(each, child, parent):
                        result = True
                        break
                return result

        return _add_cfg_page(self._cfg_page, child, parent)


    def extend_variable (self, line):
        # replace all variables
        if line == '':
            return line
        loop = 2
        while loop > 0:
            line_after = DefTemplate(line).safe_substitute(self._def_dict)
            if line == line_after:
                break
            loop -= 1
            line = line_after
        return line_after

    def reformat_number_per_type (self, item, value):
        if check_quote(value) or value.startswith('{'):
            return value
        return value

    def build_cfg_list (self):

        # Add the pages for each root knob
        for knob in self.schema.knobs:
            if not self.add_cfg_page(child='.'.join([knob.namespace, knob.name]), parent=knob.namespace, title=knob.name):
                # The parent page may not exist yet
                self.add_cfg_page(child=knob.namespace, title=knob.namespace)
                if not self.add_cfg_page(child='.'.join([knob.namespace, knob.name]), parent=knob.namespace, title=knob.name):
                    raise Exception ("Failed to add page for knob %s" % knob.name)

        ret_list = []
        # below is a shim layer that connects the UI and data structure
        for idx, data in enumerate(self.schema.subknobs):
            itype = type(data.format)
            name = data.name
            ord_dict = OrderedDict()
            if itype is IntValueFormat:
                ord_dict['type'] = 'INTEGER_KNOB'
            elif itype is FloatValueFormat:
                ord_dict['type'] = 'FLOAT_KNOB'
            elif itype is BoolFormat:
                ord_dict['type'] = 'BOOL_KNOB'
            elif itype is EnumFormat:
                ord_dict['type'] = 'ENUM_KNOB'
            elif itype is StructFormat:
                ord_dict['type'] = 'STRUCT_KNOB'
            elif itype is ArrayFormat:
                ord_dict['type'] = 'ARRAY_KNOB'
            else:
                raise Exception("Unrecognized data format %s!" % str(itype))
            ord_dict['inst'] = data # TODO: this is not right
            ord_dict['order'] = idx
            ord_dict['name'] = name
            ord_dict['cname'] = name
            ord_dict['value'] = data.format.object_to_string(data.default)
            ord_dict['path'] = '.'.join([data.knob.namespace, name])
            ord_dict['help'] = data.help
            ret_list.append(ord_dict)

        return ret_list


    def get_field_value (self, top = None):
        if top is None:
            top = self.schema.knobs
        bytes = b''
        for each in top:
            # TODO: This is not fully functional when with the structure fields
            bytes += each.format.object_to_binary(each.default)
        return bytes


    def set_field_value (self, top, value_bytes, force = False):
        def _set_field_value (name, cfgs, level):
            if 'indx' not in cfgs:
                return
            act_cfg = self.get_item_by_index (cfgs['indx'])
            if force or act_cfg['value'] == '':
                value = get_bits_from_bytes (full_bytes, act_cfg['offset'] - struct_info['offset'], act_cfg['length'])
                act_val = act_cfg['value']
                if act_val == '':
                    act_val = '%d' % value
                act_val = self.reformat_number_per_type (act_cfg, act_val)
                act_cfg['value'] = self.format_value_to_str (value, act_cfg['length'], act_val)

        if 'indx' in top:
            # it is config option
            value   = bytes_to_value (value_bytes)
            act_cfg = self.get_item_by_index (top['indx'])
            act_cfg['value'] = self.format_value_to_str (value, act_cfg['length'], act_cfg['value'])
        else:
            # it is structure
            struct_info = top[CGenNCCfgData.STRUCT]
            length = struct_info['length'] // 8
            full_bytes = bytearray(value_bytes[:length])
            if len(full_bytes) < length:
                full_bytes.extend(bytearray(length - len(value_bytes)))
            self.traverse_cfg_tree (_set_field_value, top)


    def load_default_from_bin (self, bin_data):
        self.set_field_value(self._cfg_tree, bin_data, True)


    def generate_binary_array (self):
        return self.get_field_value()

    def generate_binary (self, bin_file_name):
        bin_file = open(bin_file_name, "wb")
        bin_file.write (self.generate_binary_array ())
        bin_file.close()
        return 0

    def write_delta_file (self, out_file, platform_id, out_lines):
        dlt_fd = open (out_file, "w")
        dlt_fd.write ("%s\n"   % get_copyright_header('dlt', True))
        dlt_fd.write ('#\n')
        dlt_fd.write ('# Delta configuration values for platform ID 0x%04X\n' % platform_id)
        dlt_fd.write ('#\n\n')
        for line in out_lines:
            dlt_fd.write ('%s\n' % line)
        dlt_fd.close()


    def override_default_value(self, dlt_file):
        error = 0
        dlt_lines = CGenNCCfgData.expand_include_files(dlt_file)

        platform_id = None
        for line, file_path, line_num in dlt_lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            match = re.match("\s*([\w\.]+)\s*\|\s*(.+)", line)
            if not match:
                raise Exception("Unrecognized line '%s' (File:'%s' Line:%d) !" %
                                (line, file_path, line_num + 1))

            path      = match.group(1)
            value_str = match.group(2)
            top  = self.locate_cfg_item (path)
            if not top:
                raise Exception(
                    "Invalid configuration '%s' (File:'%s' Line:%d) !" %
                    (path, file_path, line_num + 1))

            if 'indx' in top:
                act_cfg = self.get_item_by_index (top['indx'])
                bit_len = act_cfg['length']
            else:
                struct_info = top[CGenNCCfgData.STRUCT]
                bit_len     = struct_info['length']

            value_bytes = self.parse_value (value_str, bit_len)
            self.set_field_value (top, value_bytes, True)

            if path == 'PLATFORMID_CFG_DATA.PlatformId':
                platform_id = value_str

        if platform_id is None:
            platform_id = 0
            print("PLATFORMID_CFG_DATA.PlatformId is missing in file '%s' !" % (dlt_file))

        return error


    def generate_delta_file_from_bin (self, delta_file, old_data, new_data, full=False):
        self.load_default_from_bin (new_data)
        lines = []
        tag_name = ''
        level = 0
        platform_id = None
        def_platform_id = 0

        for item in self._cfg_list:
            old_val = get_bits_from_bytes (old_data, item['offset'],  item['length'])
            new_val = get_bits_from_bytes (new_data, item['offset'],  item['length'])

            full_name = item['path']
            if 'PLATFORMID_CFG_DATA.PlatformId' == full_name:
                def_platform_id = old_val
                platform_id     = new_val
            elif item['type'] != 'Reserved' and ((new_val != old_val) or full):
                val_str = self.reformat_value_str (item['value'], item['length'])
                text = '%-40s | %s' % (full_name, val_str)
                lines.append(text)

        if def_platform_id == platform_id:
            platform_id = def_platform_id

            lines.insert(0, '%-40s | %s\n\n' %
                        ('PLATFORMID_CFG_DATA.PlatformId', '0x%04X' % platform_id))

        if platform_id is None:
            print ("Platform ID is not set and will be configured to 0")
            platform_id = 0

        self.write_delta_file (delta_file, platform_id, lines)
        return 0


    def generate_delta_svd_from_bin (self, old_data, new_data):
        self.load_default_from_bin (new_data)
        lines = []
        tag_name = ''
        level = 0
        platform_id = None
        def_platform_id = 0
        items = []

        for item in self._cfg_list:
            old_val = get_bits_from_bytes (old_data, item['offset'],  item['length'])
            new_val = get_bits_from_bytes (new_data, item['offset'],  item['length'])

            full_name = item['path']
            if 'PLATFORMID_CFG_DATA.PlatformId' == full_name:
                def_platform_id = old_val
                platform_id     = new_val
            elif item['type'] != 'Reserved' and (new_val != old_val):
                val_str = self.reformat_value_str (item['value'], item['length'])
                text = '%-40s | %s' % (full_name, val_str)
                item = self.locate_cfg_item(item['path'])
                if item is None:
                    raise Exception ("Failed to locate item from path: %s" % item['path'])
                items.append(item)

        execs = []
        # The idea is that the 1st level tag content will be regenerated if changed
        for item in items:
            exec = self.locate_exec_from_item (item)
            if exec == None:
                raise Exception ("Failed to find the immediate executive tree for an item")
            if exec not in execs:
                execs.append (exec)

        bytes_array = []
        for exec in execs:
            bytes = self.get_field_value (exec)
            offset = 0
            offset += int(exec['CfgHeader']['length'], 0)
            offset += int(exec['CondValue']['length'], 0)
            bytes_array.append (bytes[offset:])

        # self.write_delta_file (delta_file, platform_id, lines)
        return (execs, bytes_array)

    def locate_exec_from_item (self, item):

        def _locate_exec_from_item (name, cfgs, level):
            if level == 1:
                exec[0] = cfgs
            elif cfgs == item:
                exec[1] = exec[0]

        exec = [None, None]
        self.traverse_cfg_tree (_locate_exec_from_item, self._cfg_tree)
        return exec[1]

    def locate_exec_from_tag (self, tag):

        def _locate_exec_from_tag (name, cfgs, level):
            if level == 1:
                exec[0] = cfgs
                if CGenNCCfgData.STRUCT in cfgs:
                    cfghdr  = self.get_item_by_index (cfgs['CfgHeader']['indx'])
                    tag_val = array_str_to_value(cfghdr['value']) >> 20
                    if tag_val == tag:
                        exec[1] = exec[0]

        exec = [None, None]
        self.traverse_cfg_tree (_locate_exec_from_tag, self._cfg_tree)
        return exec[1]

    def generate_delta_file(self, delta_file, bin_file, bin_file2, full=False):
        fd = open (bin_file, 'rb')
        new_data = bytearray(fd.read())
        fd.close()

        if bin_file2 == '':
            old_data = self.generate_binary_array()
        else:
            old_data = new_data
            fd = open (bin_file2, 'rb')
            new_data = bytearray(fd.read())
            fd.close()

        return self.generate_delta_file_from_bin (delta_file, old_data, new_data, full)


    def load_xml (self, cfg_file):
        self.initialize ()
        # dir_path = os.path.dirname(os.path.abspath(__file__))
        # xsd = xmlschema.XMLSchema(os.path.join(dir_path, 'configschema.xsd'))
        # if not xsd.is_valid(cfg_file):
        #     raise Exception ("Input xml does not meet corresponding schema")
        self.schema = Schema.load (cfg_file)

        self.knob_shim = self.build_cfg_list()
        return 0


def usage():
    print ('\n'.join([
          "GenNCCfgData Version 0.1",
          "Usage:",
          "    GenNCCfgData  GENBIN  XmlFile[;DltFile]   BinOutFile",
          "    GenNCCfgData  GENDLT  XmlFile[;BinFile]   DltOutFile"
          ]))


def main():
    # Parse the options and args
    argc = len(sys.argv)
    if argc < 4 or argc > 5:
        usage()
        return 1

    gen_cfg_data = CGenNCCfgData()
    command   = sys.argv[1].upper()
    out_file  = sys.argv[3]

    file_list  = sys.argv[2].split(';')
    if len(file_list) >= 2:
        xml_file   = file_list[0]
        dlt_file   = file_list[1]
    elif len(file_list) == 1:
        xml_file   = file_list[0]
        dlt_file   = ''
    else:
        raise Exception ("ERROR: Invalid parameter '%s' !" % sys.argv[2])

    if command == "GENDLT" and xml_file.endswith('.dlt'):
        # It needs to expand an existing DLT file
        dlt_file = xml_file
        lines  = gen_cfg_data.expand_include_files (dlt_file)
        write_lines (lines, out_file)
        return 0

    cfg_bin_file  = ''
    cfg_bin_file2 = ''
    if dlt_file:
        if command == "GENDLT":
            cfg_bin_file = dlt_file
            dlt_file  = ''
            if len(file_list) >= 3:
                cfg_bin_file2 = file_list[2]

    gen_cfg_data.load_xml (xml_file)

    if dlt_file:
        gen_cfg_data.override_default_value(dlt_file)

    if   command == "GENBIN":
        if len(file_list) == 3:
            old_data = gen_cfg_data.generate_binary_array()
            fi   = open (file_list[2], 'rb')
            new_data = bytearray (fi.read ())
            fi.close ()
            if len(new_data) != len(old_data):
                raise Exception ("Binary file '%s' length does not match, ignored !" % file_list[2])
            else:
                gen_cfg_data.load_default_from_bin (new_data)
                gen_cfg_data.override_default_value(dlt_file)

        gen_cfg_data.generate_binary(out_file)

    elif command == "GENDLT":
        gen_cfg_data.generate_delta_file (out_file, cfg_bin_file, cfg_bin_file2)

    else:
        raise Exception ("Unsuported command '%s' !" % command)

    return 0


if __name__ == '__main__':
    sys.exit(main())

