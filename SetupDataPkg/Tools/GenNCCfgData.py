## @ GenNCCfgData.py
#
# Copyright (c) 2020, Intel Corporation. All rights reserved.<BR>
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: BSD-2-Clause-Patent
#
##

import os
import sys
import re
import struct
import marshal
import pprint
import string
import operator as op
import ast
import binascii
from   datetime    import date
from   collections import OrderedDict
import xml.etree.ElementTree as ET
import xmltodict
import xmlschema

from CommonUtility import *

# Generated file copyright header
__copyright_tmp__ = """/** @file

  Platform Configuration %s File.

  Copyright (c) %4d, Intel Corporation. All rights reserved.<BR>
  Copyright (c) Microsoft Corporation.
  SPDX-License-Identifier: BSD-2-Clause-Patent

  This file is automatically generated. Please do NOT modify !!!

**/
"""

def get_copyright_header (file_type, allow_modify = False):
    file_description = {
        'yaml': 'Boot Setting',
        'dlt' : 'Delta',
        'inc' : 'C Binary Blob',
        'h'   : 'C Struct Header'
    }
    if file_type in ['yaml', 'dlt']:
        comment_char = '#'
    else:
        comment_char = ''
    lines = __copyright_tmp__.split('\n')
    if allow_modify:
      lines = [line for line in lines if 'Please do NOT modify' not in line]
    copyright_hdr = '\n'.join('%s%s' % (comment_char, line) for line in lines)[:-1] + '\n'
    return copyright_hdr % (file_description[file_type], date.today().year)

def check_quote (text):
    if (text[0] == "'" and text[-1] == "'") or (text[0] == '"' and text[-1] == '"'):
        return True
    return False

def strip_quote (text):
    new_text = text.strip()
    if check_quote (new_text):
        return new_text[1:-1]
    return text

def strip_delimiter (text, delim):
    new_text = text.strip()
    if new_text:
        if new_text[0] == delim[0] and new_text[-1] == delim[-1]:
            return new_text[1:-1]
    return text

def bytes_to_bracket_str (bytes):
    return '{ %s }' % (', '.join('0x%02x' % i for i in bytes))

def array_str_to_value (val_str):
    val_str = val_str.strip()
    val_str = strip_delimiter (val_str, '{}')
    val_str = strip_quote (val_str)
    value = 0
    for each in val_str.split(',')[::-1]:
        each = each.strip()
        value = (value << 8) | int(each, 0)
    return value

def write_lines (lines, file):
    fo = open(file, "w")
    fo.write (''.join ([x[0] for x in lines]))
    fo.close ()

def read_lines (file):
    if not os.path.exists(file):
        test_file = os.path.basename(file)
        if os.path.exists(test_file):
            file = test_file
    fi = open (file, 'r')
    lines = fi.readlines ()
    fi.close ()
    return lines

def expand_file_value (path, value_str):
    result = bytearray()
    match  = re.match("\{\s*FILE:(.+)\}", value_str)
    if match:
        file_list = match.group(1).split(',')
        for file in file_list:
            file = file.strip()
            bin_path = os.path.join(path, file)
            result.extend(bytearray(open(bin_path, 'rb').read()))
    return result


class CGenNCCfgData:
    STRUCT         = '$STRUCT'
    bits_width     = {'b':1, 'B':8, 'W':16, 'D':32, 'Q':64}
    builtin_option = {'$EN_DIS' : [('0', 'Disable'), ('1', 'Enable')]}
    exclude_struct = ['Enums']
    include_tag    = ['GPIO_CFG_DATA']
    keyword_set    = set(['@name', '@default', '@help', '@deprecated'])
    config_list    = ['Knobs']

    def __init__(self):
        self.initialize ()


    def initialize (self):
        self._cfg_tree  = {}
        self._tmp_tree  = {}
        self._cfg_list  = []
        self._cfg_page  = {'root': {'title': '', 'child': []}}
        self._cur_page  = ''
        self._var_dict  = {}
        self._def_dict  = {}
        self._yaml_path = ''


    @staticmethod
    def deep_convert_dict (layer):
        # convert OrderedDict to list + dict
        new_list = layer
        if isinstance(layer, OrderedDict):
            new_list = list (layer.items())
            for idx, pair in enumerate (new_list):
                new_node = CGenNCCfgData.deep_convert_dict (pair[1])
                new_list[idx] = dict({pair[0] : new_node})
        return new_list


    @staticmethod
    def deep_convert_list (layer):
        if isinstance(layer, list):
            od = OrderedDict({})
            for each in layer:
                if isinstance(each, dict):
                    key = next(iter(each))
                    od[key] = CGenNCCfgData.deep_convert_list(each[key])
            return od
        else:
            return layer


    @staticmethod
    def expand_include_files (file_path, cur_dir = ''):
        if cur_dir == '':
            cur_dir   = os.path.dirname(file_path)
            file_path = os.path.basename(file_path)

        input_file_path = os.path.join(cur_dir, file_path)
        file  = open(input_file_path, "r")
        lines = file.readlines()
        file.close()

        new_lines = []
        for line_num, line in enumerate(lines):
            match = re.match("^!include\s*(.+)?$", line.strip())
            if match:
                inc_path = match.group(1)
                tmp_path = os.path.join(cur_dir, inc_path)
                org_path = tmp_path
                if not os.path.exists(tmp_path):
                    cur_dir = os.path.join(os.path.dirname (os.path.realpath(__file__)), "..", "..")
                tmp_path = os.path.join(cur_dir, inc_path)
                if not os.path.exists(tmp_path):
                    raise Exception ("ERROR: Cannot open include file '%s'." % org_path)
                else:
                    new_lines.append (('# Included from file: %s\n' % inc_path, tmp_path, 0))
                    new_lines.append (('# %s\n' % ('=' * 80), tmp_path, 0))
                    new_lines.extend (CGenNCCfgData.expand_include_files (inc_path, cur_dir))
            else:
                new_lines.append ((line, input_file_path, line_num))

        return new_lines


    @staticmethod
    def format_struct_field_name (input, count = 0):
        name = ''
        cap  = True
        if '_' in input:
            input = input.lower()
        for each in input:
          if each == '_':
              cap = True
              continue
          elif cap:
              each = each.upper()
              cap  = False
          name = name + each

        if count > 1:
            name = '%s[%d]' % (name, count)

        return name

    def get_last_error (self):
        return ''


    def get_variable (self, var, attr = 'value'):
        if var in self._var_dict:
            var = self._var_dict[var]
            return var

        item = self.locate_cfg_item (var, False)
        if item is None:
            raise ValueError ("Cannot find variable '%s' !" % var)

        if item:
            if 'indx' in item:
                item = self.get_item_by_index (item['indx'])
            if attr == 'offset':
                var  = item['offset']
            elif attr == 'length':
                var  = item['length']
            elif attr == 'value':
                var  = self.get_cfg_item_value (item)
            else:
                raise ValueError ("Unsupported variable attribute '%s' !" % attr)
        return var


    def eval (self, expr):
        def _handler (pattern):
            if pattern.group(1):
                target = 1
            else:
                target = 2
            result = self.get_variable(pattern.group(target))
            if result is None:
                raise ValueError('Unknown variable $(%s) !' % pattern.group(target))
            return hex(result)

        expr_eval = ExpressionEval ()
        if '$' in expr:
            # replace known variable first
            expr = re.sub(r'\$\(([_a-zA-Z][\w\.]*)\)|\$([_a-zA-Z][\w\.]*)', _handler, expr)
        return expr_eval.eval(expr, self.get_variable)


    def get_cfg_list (self, page_id = None):
        if page_id is None:
            # return full list
            return self._cfg_list
        else:
            # build a new list for items under a page ID
            cfgs =  [i for i in self._cfg_list if i['cname'] and (i['page'] == page_id)]
            return cfgs


    def get_cfg_page (self):
        return self._cfg_page

    def get_cfg_item_length (self, item):
        return item['length']

    def get_cfg_item_value (self, item, array = False):
        value_str = item['value']
        length    = item['length']
        return  self.get_value (value_str, length, array)


    def format_value_to_str (self, value, bit_length, old_value = ''):
        # value is always int
        length    = (bit_length + 7) // 8
        fmt = ''
        if old_value.startswith ('0x'):
            fmt = '0x'
        elif old_value and (old_value[0] in ['"', "'", '{']):
            fmt = old_value[0]
        else:
            fmt = ''

        bvalue = value_to_bytearray (value, length)
        if fmt in ['"', "'"]:
            svalue = bvalue.rstrip(b'\x00').decode()
            value_str = fmt + svalue + fmt
        elif fmt == "{":
            value_str = '{ ' + ', '.join(['0x%02x' % i for i in bvalue]) + ' }'
        elif fmt == '0x':
            hex_len = length * 2
            if len(old_value) == hex_len + 2:
                fstr = '0x%%0%dX' % hex_len
            else:
                fstr = '0x%X'
            value_str = fstr % value
        else:
            if length <= 2:
                value_str = '%d'   % value
            elif length <= 8:
                value_str = '0x%x' % value
            else:
                value_str = '{ ' + ', '.join(['0x%02x' % i for i in bvalue]) + ' }'
        return value_str


    def reformat_value_str (self, value_str, bit_length, old_value = None):
        value = self.parse_value (value_str, bit_length, False)
        if old_value is None:
            old_value = value_str
        new_value = self.format_value_to_str (value, bit_length, old_value)
        return new_value


    def get_value (self, value_str, bit_length, array = True):
        value_str = value_str.strip()
        if len(value_str) == 0:
            return 0
        if value_str[0] == "'" and value_str[-1] == "'" or \
           value_str[0] == '"' and value_str[-1] == '"':
            value_str = value_str[1:-1]
            bvalue = bytearray (value_str.encode())
            if len(bvalue) == 0:
                bvalue = bytearray(b'\x00')
            if array:
                return  bvalue
            else:
                return  bytes_to_value (bvalue)
        else:
            if value_str[0] in '{' :
                value_str = value_str[1:-1].strip()
            value = 0
            for each in value_str.split(',')[::-1]:
                each = each.strip()
                value = (value << 8) | int(each, 0)
            if array:
                length = (bit_length + 7) // 8
                return value_to_bytearray (value, length)
            else:
                return value


    def parse_value (self, value_str, bit_length, array = True):
        length = (bit_length + 7) // 8
        if check_quote(value_str):
            value_str = bytes_to_bracket_str(value_str[1:-1].encode())
        elif (',' in value_str) and (value_str[0] != '{'):
            value_str = '{ %s }' % value_str
        if value_str[0] == '{':
            result = expand_file_value (self._yaml_path, value_str)
            if len(result) == 0 :
                bin_list = value_str[1:-1].split(',')
                value            = 0
                bit_len          = 0
                unit_len         = 1
                for idx, element in enumerate(bin_list):
                    each = element.strip()
                    if len(each) == 0:
                        continue

                    in_bit_field = False
                    if each[0] in "'" + '"':
                        each_value = bytearray(each[1:-1], 'utf-8')
                    elif ':' in each:
                        match    = re.match("^(.+):(\d+)([b|B|W|D|Q])$", each)
                        if match is None:
                            raise SystemExit("Exception: Invald value list format '%s' !" % each)
                        if match.group(1) == '0' and match.group(2) == '0':
                            unit_len = CGenNCCfgData.bits_width[match.group(3)] // 8
                        cur_bit_len = int(match.group(2)) * CGenNCCfgData.bits_width[match.group(3)]
                        value   += ((self.eval(match.group(1)) & (1<<cur_bit_len) - 1)) << bit_len
                        bit_len += cur_bit_len
                        each_value = bytearray()
                        if idx + 1 < len(bin_list):
                            in_bit_field = True
                    else:
                        try:
                            each_value = value_to_bytearray(self.eval(each.strip()), unit_len)
                        except:
                            raise SystemExit("Exception: Value cannot fit into %s bytes !" % (each, unit_len))

                    if not in_bit_field:
                        if bit_len > 0:
                            if bit_len % 8 != 0:
                                raise SystemExit("Exception: Invalid bit field alignment '%s' !" % value_str)
                            result.extend(value_to_bytes(value, bit_len // 8))
                        value   = 0
                        bit_len = 0

                    result.extend(each_value)

        elif check_quote (value_str):
            result = bytearray(value_str[1:-1], 'utf-8')  # Excluding quotes
        else:
            result = value_to_bytearray (self.eval(value_str), length)

        if len(result) < length:
            result.extend(b'\x00' * (length - len(result)))
        elif len(result) > length:
            raise SystemExit ("Exception: Value '%s' is too big to fit into %d bytes !" % (value_str, length))

        if array:
            return result
        else:
            return bytes_to_value(result)

        return result


    def get_cfg_item_options (self, item):
        tmp_list = []
        if  item['type'] == "Combo":
            if item['option'] in CGenNCCfgData.builtin_option:
                for op_val, op_str in CGenNCCfgData.builtin_option[item['option']]:
                    tmp_list.append((op_val, op_str))
            else:
                opt_list = item['option'].split(',')
                for option in opt_list:
                    option = option.strip()
                    try:
                        (op_val, op_str) = option.split(':')
                    except:
                        raise SystemExit ("Exception: Invalid option format '%s' for item '%s' !" % (option, item['cname']))
                    tmp_list.append((op_val, op_str))
        return  tmp_list


    def get_page_title(self, page_id, top = None):
        if top is None:
            top = self.get_cfg_page()['root']
        for node in top['child']:
            page_key = next(iter(node))
            if page_id == page_key:
                return node[page_key]['title']
            else:
                result = self.get_page_title (page_id, node[page_key])
                if result is not None:
                    return result
        return None


    def print_pages(self, top=None, level=0):
        if top is None:
            top = self.get_cfg_page()['root']
        for node in top['child']:
            page_id = next(iter(node))
            print('%s%s: %s' % ('  ' * level, page_id, node[page_id]['title']))
            level += 1
            self.print_pages(node[page_id], level)
            level -= 1


    def get_item_by_index (self, index):
        return self._cfg_list[index]


    def get_item_by_path (self, path):
        node = self.locate_cfg_item (path)
        if node:
            return self.get_item_by_index (node['indx'])
        else:
            return None

    def locate_cfg_path (self, item):
        def _locate_cfg_path (root, level = 0):
            # config structure
            if item is root:
                return path
            for key in root:
                if type(root[key]) is OrderedDict:
                    level += 1
                    path.append(key)
                    ret = _locate_cfg_path (root[key], level)
                    if ret:
                        return ret
                    path.pop()
            return None
        path = []
        return _locate_cfg_path (self._cfg_tree)


    def locate_cfg_item (self, path, allow_exp = True):
        def _locate_cfg_item (root, path, level = 0):
            if len(path) == level:
                return root
            next_root = root.get(path[level], None)
            if next_root is None:
                if allow_exp:
                    raise Exception ('Not a valid CFG config option path: %s' % '.'.join(path[:level+1]))
                else:
                    return None
            return _locate_cfg_item (next_root, path, level + 1)

        path_nodes = path.split('.')
        return _locate_cfg_item (self._cfg_tree, path_nodes)


    def traverse_cfg_tree (self, handler, top = None):
        def _traverse_cfg_tree (root, level = 0):
            # config structure
            for key in root:
                if type(root[key]) is OrderedDict:
                    level += 1
                    handler (key, root[key], level)
                    _traverse_cfg_tree (root[key], level)
                    level -= 1

        if top is None:
            top = self._cfg_tree
        _traverse_cfg_tree (top)


    def print_cfgs(self, root = None, short = True, print_level = 256):
        def _print_cfgs (name, cfgs, level):

            if 'indx' in cfgs:
                act_cfg = self.get_item_by_index (cfgs['indx'])
            else:
                offset = 0
                length = 0
                value  = ''
                path=''
                if CGenNCCfgData.STRUCT in cfgs:
                    cfg = cfgs[CGenNCCfgData.STRUCT]
                    offset = int(cfg['offset'])
                    length = int(cfg['length'])
                    if 'value' in cfg:
                        value = cfg['value']
                if length == 0:
                    return
                act_cfg = dict({'value' : value, 'offset' : offset, 'length' : length})
            value   = act_cfg['value']
            bit_len = act_cfg['length']
            offset  = (act_cfg['offset'] + 7) // 8
            if value != '':
                try:
                    value = self.reformat_value_str (act_cfg['value'], act_cfg['length'])
                except:
                    value = act_cfg['value']
            length  = bit_len // 8
            bit_len = '(%db)' % bit_len if bit_len % 8 else '' * 4
            if level <= print_level:
                if short and len(value) > 40:
                    value = '%s ... %s' % (value[:20] , value[-20:])
                print('%04X:%04X%-6s %s%s : %s' % (offset, length, bit_len, '  ' * level, name, value))

        self.traverse_cfg_tree (_print_cfgs)


    def get_cfg_tree(self):
        return self._cfg_tree


    def set_cfg_tree(self, cfg_tree):
        self._cfg_tree = cfg_tree


    def merge_cfg_tree(self, root, other_root):
        ret = OrderedDict ()
        prev_key = None
        for other_key in other_root:
            if other_key not in root:
                ret[other_key] = other_root[other_key]
            else:
                # this is a good time to check to see if we miss anything from previous root elements
                found_last = False
                for key in root:
                    if key == prev_key:
                        found_last = True
                        continue
                    if prev_key == None:
                        found_last = True
                    if found_last:
                        ret[key] = root[key]
                    if key == other_key:
                        prev_key = other_key
                        break

                if type(root[other_key]) is OrderedDict and type(other_root[other_key]) is OrderedDict:
                    # if they are both non-leaf, great, process recursively
                    ret[other_key] = self.merge_cfg_tree (root[other_key], other_root[other_key])
                elif type(root[other_key]) is OrderedDict or type(other_root[other_key]) is OrderedDict:
                    raise Exception ("Two yamls files have hierachy mismatch!!!")
                else:
                    # this is duplicate value in from both roots, take original root as principal
                    ret[other_key] = root[other_key]

        # See if there is any leftovers
        found_last = False
        for key in root:
            if key == prev_key:
                found_last = True
                continue
            if prev_key == None:
                found_last = True
            if found_last:
                ret[key] = root[key]
            if key == other_key:
                prev_key = other_key
                break
        return ret


    def build_var_dict (self):
        def _build_var_dict (name, cfgs, level):
            if level <= 2:
                if CGenNCCfgData.STRUCT in cfgs:
                    struct_info = cfgs[CGenNCCfgData.STRUCT]
                    self._var_dict['_LENGTH_%s_' % name] = struct_info['length'] // 8
                    self._var_dict['_OFFSET_%s_' % name] = struct_info['offset'] // 8

        self._var_dict  = {}
        self.traverse_cfg_tree (_build_var_dict)
        self._var_dict['_LENGTH_'] = self._cfg_tree[CGenNCCfgData.STRUCT]['length'] // 8
        return 0


    def add_cfg_page(self, child, parent, title=''):
        def _add_cfg_page(cfg_page, child, parent):
            key = next(iter(cfg_page))
            if parent == key:
                cfg_page[key]['child'].append({child: {'title': title,
                                                       'child': []}})
                return True
            else:
                result = False
                for each in cfg_page[key]['child']:
                    if _add_cfg_page(each, child, parent):
                        result = True
                        break
                return result

        return _add_cfg_page(self._cfg_page, child, parent)


    def set_cur_page(self, page_str):
        if not page_str:
            return

        if ',' in page_str:
            page_list = page_str.split(',')
        else:
            page_list = [page_str]
        for page_str in page_list:
            parts = page_str.split(':')
            if len(parts) in [1, 3]:
                page = parts[0].strip()
                if len(parts) == 3:
                    # it is a new page definition, add it into tree
                    parent = parts[1] if parts[1] else 'root'
                    parent = parent.strip()
                    if parts[2][0] == '"' and parts[2][-1] == '"':
                        parts[2] = parts[2][1:-1]

                    if not self.add_cfg_page(page, parent, parts[2]):
                        raise SystemExit("Error: Cannot find parent page '%s'!" % parent)
            else:
                raise SystemExit("Error: Invalid page format '%s' !" % page_str)
            self._cur_page = page


    def extend_variable (self, line):
        # replace all variables
        if line == '':
            return line
        loop = 2
        while loop > 0:
            line_after = DefTemplate(line).safe_substitute(self._def_dict)
            if line == line_after:
                break
            loop -= 1
            line = line_after
        return line_after

    def reformat_number_per_type (self, itype, value):
        if check_quote(value) or value.startswith('{'):
            return value
        parts = itype.split(',')
        if len(parts) > 3 and parts[0] == 'EditNum':
            num_fmt = parts[1].strip()
        else:
            num_fmt = ''
        if num_fmt == 'HEX' and not value.startswith('0x'):
            value = '0x%X' % int(value, 10)
        elif num_fmt == 'DEC' and value.startswith('0x'):
            value = '%d' % int(value, 16)
        return value

    def add_cfg_item(self, name, item, offset, path):

        self.set_cur_page (item.get('page', ''))

        if not set(item).issubset(CGenNCCfgData.keyword_set):
            for each in list(item):
                if each not in CGenNCCfgData.keyword_set:
                    raise Exception ("Invalid attribute '%s' for '%s'!" % (each, '.'.join(path)))

        length = item.get('length', 0)
        if type(length) is str:
            match = re.match("^(\d+)([b|B|W|D|Q])([B|W|D|Q]?)\s*$", length)
            if match:
                unit_len = CGenNCCfgData.bits_width[match.group(2)]
                length = int(match.group(1), 10) * unit_len
            else:
                try:
                    length = int(length, 0) * 8
                except:
                    raise Exception ("Invalid length field '%s' for '%s' !" % (length, '.'.join(path)))

                if offset % 8 > 0:
                    raise Exception ("Invalid alignment for field '%s' for '%s' !" % (name, '.'.join(path)))
        else:
            # define is length in bytes
            length = length * 8

        if not name.isidentifier():
            raise Exception ("Invalid config name '%s' for '%s' !" % (name, '.'.join(path)))


        itype = str(item.get('type', 'Reserved'))
        value = str(item.get('value', ''))
        if value:
            if not (check_quote(value) or value.startswith('{')):
                if ',' in value:
                    value = '{ %s }' % value
                else:
                    value = self.reformat_number_per_type (itype, value)

        help = str(item.get('help', ''))
        if '\n' in help:
            help = ' '.join ([i.strip() for i in help.splitlines()])

        option = str(item.get('option', ''))
        if '\n' in option:
            option = ' '.join ([i.strip() for i in option.splitlines()])

        # extend variables for value and condition
        condition = str(item.get('condition', ''))
        if condition:
            condition = self.extend_variable (condition)
        value     = self.extend_variable (value)

        order = str(item.get('order', ''))
        if order:
            if '.' in order:
                (major, minor) = order.split('.')
                order = int (major, 16)
            else:
                order = int (order, 16)
        else:
            order = offset

        cfg_item = dict()
        cfg_item['length'] = length
        cfg_item['offset'] = offset
        cfg_item['value']  = value
        cfg_item['type']   = itype
        cfg_item['cname']  = str(name)
        cfg_item['name']   = str(item.get('name', ''))
        cfg_item['help']   = help
        cfg_item['option'] = option
        cfg_item['page']   = self._cur_page
        cfg_item['order']  = order
        cfg_item['path']   = '.'.join(path)
        cfg_item['condition']  = condition
        if 'struct' in item:
            cfg_item['struct'] = item['struct']
        self._cfg_list.append(cfg_item)

        item['indx']       = len(self._cfg_list) - 1

        # remove used info for reducing pkl size
        item.pop('option', None)
        item.pop('condition', None)
        item.pop('help', None)
        item.pop('name', None)
        item.pop('page', None)

        return length


    def build_cfg_list (self, cfg_name ='', top = None, path = [], info = {'offset': 0}):
        if top is None:
            top = self._cfg_tree

        if cfg_name in CGenNCCfgData.exclude_struct:
            # skip peripheral nodes
            return 0

        start = info['offset']
        is_leaf = True
        for key in top:
            path.append(key)
            if type(top[key]) is OrderedDict:
                is_leaf = False
                self.build_cfg_list(key, top[key], path, info)
            path.pop()

        if is_leaf:
            print (cfg_name)
            length = self.add_cfg_item(cfg_name, top, info['offset'], path)
            info['offset'] += length
        elif cfg_name == '' or (cfg_name and cfg_name[0] != '$'):
            # check first element for struct
            first = next(iter(top))
            struct_str = CGenNCCfgData.STRUCT
            if first != struct_str:
                struct_node = OrderedDict({})
                top[struct_str] = struct_node
                top.move_to_end (struct_str, False)
            else:
                struct_node = top[struct_str]
            struct_node['offset'] = start
            if len(path) == 1:
                # Round up first layer tree to be 4 Byte aligned
                info['offset'] = (info['offset'] + 31) & (~31)
                struct_node['length'] = (info['offset'] - start + 31) & (~31)
            else:
                struct_node['length'] = info['offset'] - start
            if struct_node['length'] % 8 != 0:
                raise SystemExit("Error: Bits length not aligned for %s !" % str(path))


    def get_field_value (self, top = None):
        def _get_field_value (name, cfgs, level):
            if 'indx' in cfgs:
                act_cfg = self.get_item_by_index (cfgs['indx'])
                if act_cfg['length'] == 0:
                    return
                value = self.get_value (act_cfg['value'], act_cfg['length'], False)
                set_bits_to_bytes (result, act_cfg['offset'] - struct_info['offset'], act_cfg['length'], value)

        if top is None:
            top = self._cfg_tree
        struct_info = top[CGenNCCfgData.STRUCT]
        result = bytearray ((struct_info['length'] + 7) // 8)
        self.traverse_cfg_tree (_get_field_value, top)
        return  result


    def set_field_value (self, top, value_bytes, force = False):
        def _set_field_value (name, cfgs, level):
            if 'indx' not in cfgs:
                return
            act_cfg = self.get_item_by_index (cfgs['indx'])
            if force or act_cfg['value'] == '':
                value = get_bits_from_bytes (full_bytes, act_cfg['offset'] - struct_info['offset'], act_cfg['length'])
                act_val = act_cfg['value']
                if act_val == '':
                    act_val = '%d' % value
                act_val = self.reformat_number_per_type (act_cfg['type'], act_val)
                act_cfg['value'] = self.format_value_to_str (value, act_cfg['length'], act_val)

        if 'indx' in top:
            # it is config option
            value   = bytes_to_value (value_bytes)
            act_cfg = self.get_item_by_index (top['indx'])
            act_cfg['value'] = self.format_value_to_str (value, act_cfg['length'], act_cfg['value'])
        else:
            # it is structure
            struct_info = top[CGenNCCfgData.STRUCT]
            length = struct_info['length'] // 8
            full_bytes = bytearray(value_bytes[:length])
            if len(full_bytes) < length:
                full_bytes.extend(bytearray(length - len(value_bytes)))
            self.traverse_cfg_tree (_set_field_value, top)


    def update_def_value (self):
        def _update_def_value (name, cfgs, level):
            if 'indx' in cfgs:
                act_cfg = self.get_item_by_index (cfgs['indx'])
                if act_cfg['value'] != '' and act_cfg['length'] > 0:
                    try:
                        act_cfg['value'] = self.reformat_value_str (act_cfg['value'], act_cfg['length'])
                    except:
                        raise Exception ("Invalid value expression '%s' for '%s' !" % (act_cfg['value'], act_cfg['path']))
            else:
                if CGenNCCfgData.STRUCT in cfgs and 'value' in cfgs[CGenNCCfgData.STRUCT]:
                    curr = cfgs[CGenNCCfgData.STRUCT]
                    value_bytes = value_to_bytearray (self.eval(curr['value']), (curr['length'] + 7) // 8)
                    self.set_field_value (cfgs, value_bytes)

        self.traverse_cfg_tree (_update_def_value, self._cfg_tree)


    def evaluate_condition (self, item):
        expr = item['condition']
        result = self.parse_value (expr, 1, False)
        return result


    def load_default_from_bin (self, bin_data):
        self.set_field_value(self._cfg_tree, bin_data, True)


    def generate_binary_array (self):
        return self.get_field_value()

    def generate_binary (self, bin_file_name):
        bin_file = open(bin_file_name, "wb")
        bin_file.write (self.generate_binary_array ())
        bin_file.close()
        return 0

    def write_delta_file (self, out_file, platform_id, out_lines):
        dlt_fd = open (out_file, "w")
        dlt_fd.write ("%s\n"   % get_copyright_header('dlt', True))
        dlt_fd.write ('#\n')
        dlt_fd.write ('# Delta configuration values for platform ID 0x%04X\n' % platform_id)
        dlt_fd.write ('#\n\n')
        for line in out_lines:
            dlt_fd.write ('%s\n' % line)
        dlt_fd.close()


    def override_default_value(self, dlt_file):
        error = 0
        dlt_lines = CGenNCCfgData.expand_include_files(dlt_file)

        platform_id = None
        for line, file_path, line_num in dlt_lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            match = re.match("\s*([\w\.]+)\s*\|\s*(.+)", line)
            if not match:
                raise Exception("Unrecognized line '%s' (File:'%s' Line:%d) !" %
                                (line, file_path, line_num + 1))

            path      = match.group(1)
            value_str = match.group(2)
            top  = self.locate_cfg_item (path)
            if not top:
                raise Exception(
                    "Invalid configuration '%s' (File:'%s' Line:%d) !" %
                    (path, file_path, line_num + 1))

            if 'indx' in top:
                act_cfg = self.get_item_by_index (top['indx'])
                bit_len = act_cfg['length']
            else:
                struct_info = top[CGenNCCfgData.STRUCT]
                bit_len     = struct_info['length']

            value_bytes = self.parse_value (value_str, bit_len)
            self.set_field_value (top, value_bytes, True)

            if path == 'PLATFORMID_CFG_DATA.PlatformId':
                platform_id = value_str

        if platform_id is None:
            platform_id = 0
            print("PLATFORMID_CFG_DATA.PlatformId is missing in file '%s' !" % (dlt_file))

        return error


    def generate_delta_file_from_bin (self, delta_file, old_data, new_data, full=False):
        self.load_default_from_bin (new_data)
        lines = []
        tag_name = ''
        level = 0
        platform_id = None
        def_platform_id = 0

        for item in self._cfg_list:
            old_val = get_bits_from_bytes (old_data, item['offset'],  item['length'])
            new_val = get_bits_from_bytes (new_data, item['offset'],  item['length'])

            full_name = item['path']
            if 'PLATFORMID_CFG_DATA.PlatformId' == full_name:
                def_platform_id = old_val
                platform_id     = new_val
            elif item['type'] != 'Reserved' and ((new_val != old_val) or full):
                val_str = self.reformat_value_str (item['value'], item['length'])
                text = '%-40s | %s' % (full_name, val_str)
                lines.append(text)

        if def_platform_id == platform_id:
            platform_id = def_platform_id

            lines.insert(0, '%-40s | %s\n\n' %
                        ('PLATFORMID_CFG_DATA.PlatformId', '0x%04X' % platform_id))

        if platform_id is None:
            print ("Platform ID is not set and will be configured to 0")
            platform_id = 0

        self.write_delta_file (delta_file, platform_id, lines)
        return 0


    def generate_delta_svd_from_bin (self, old_data, new_data):
        self.load_default_from_bin (new_data)
        lines = []
        tag_name = ''
        level = 0
        platform_id = None
        def_platform_id = 0
        items = []

        for item in self._cfg_list:
            old_val = get_bits_from_bytes (old_data, item['offset'],  item['length'])
            new_val = get_bits_from_bytes (new_data, item['offset'],  item['length'])

            full_name = item['path']
            if 'PLATFORMID_CFG_DATA.PlatformId' == full_name:
                def_platform_id = old_val
                platform_id     = new_val
            elif item['type'] != 'Reserved' and (new_val != old_val):
                val_str = self.reformat_value_str (item['value'], item['length'])
                text = '%-40s | %s' % (full_name, val_str)
                item = self.locate_cfg_item(item['path'])
                if item is None:
                    raise Exception ("Failed to locate item from path: %s" % item['path'])
                items.append(item)

        execs = []
        # The idea is that the 1st level tag content will be regenerated if changed
        for item in items:
            exec = self.locate_exec_from_item (item)
            if exec == None:
                raise Exception ("Failed to find the immediate executive tree for an item")
            if exec not in execs:
                execs.append (exec)

        bytes_array = []
        for exec in execs:
            bytes = self.get_field_value (exec)
            offset = 0
            offset += int(exec['CfgHeader']['length'], 0)
            offset += int(exec['CondValue']['length'], 0)
            bytes_array.append (bytes[offset:])

        # self.write_delta_file (delta_file, platform_id, lines)
        return (execs, bytes_array)

    def locate_exec_from_item (self, item):

        def _locate_exec_from_item (name, cfgs, level):
            if level == 1:
                exec[0] = cfgs
            elif cfgs == item:
                exec[1] = exec[0]

        exec = [None, None]
        self.traverse_cfg_tree (_locate_exec_from_item, self._cfg_tree)
        return exec[1]

    def locate_exec_from_tag (self, tag):

        def _locate_exec_from_tag (name, cfgs, level):
            if level == 1:
                exec[0] = cfgs
                if CGenNCCfgData.STRUCT in cfgs:
                    cfghdr  = self.get_item_by_index (cfgs['CfgHeader']['indx'])
                    tag_val = array_str_to_value(cfghdr['value']) >> 20
                    if tag_val == tag:
                        exec[1] = exec[0]

        exec = [None, None]
        self.traverse_cfg_tree (_locate_exec_from_tag, self._cfg_tree)
        return exec[1]

    def generate_delta_file(self, delta_file, bin_file, bin_file2, full=False):
        fd = open (bin_file, 'rb')
        new_data = bytearray(fd.read())
        fd.close()

        if bin_file2 == '':
            old_data = self.generate_binary_array()
        else:
            old_data = new_data
            fd = open (bin_file2, 'rb')
            new_data = bytearray(fd.read())
            fd.close()

        return self.generate_delta_file_from_bin (delta_file, old_data, new_data, full)


    def prepare_marshal (self, is_save):
        if is_save:
            # Ordered dict is not marshallable, convert to list
            self._cfg_tree = CGenNCCfgData.deep_convert_dict (self._cfg_tree)
        else:
            # Revert it back
            self._cfg_tree = CGenNCCfgData.deep_convert_list (self._cfg_tree)


    def get_struct_array_info (self, input):
        parts = input.split(':')
        if len(parts) > 1:
           var   = parts[1]
           input = parts[0]
        else:
           var = ''
        array_str = input.split('[')
        name     = array_str[0]
        if len(array_str) > 1:
            num_str = ''.join(c for c in array_str[-1] if c.isdigit())
            num_str = '1000' if len(num_str) == 0 else num_str
            array_num = int(num_str)
        else:
            array_num = 0
        return name, array_num, var


    def process_multilines (self, string, max_char_length):
        multilines = ''
        string_length = len(string)
        current_string_start = 0
        string_offset = 0
        break_line_dict = []
        if len(string) <= max_char_length:
            while (string_offset < string_length):
                if string_offset >= 1:
                    if string[string_offset - 1] == '\\' and string[string_offset] == 'n':
                        break_line_dict.append (string_offset + 1)
                string_offset += 1
            if break_line_dict != []:
                for each in break_line_dict:
                    multilines += "  %s\n" % string[current_string_start:each].lstrip()
                    current_string_start = each
                if string_length - current_string_start > 0:
                    multilines += "  %s\n" % string[current_string_start:].lstrip()
            else:
                multilines = "  %s\n" % string
        else:
            new_line_start = 0
            new_line_count = 0
            found_space_char = False
            while (string_offset < string_length):
                if string_offset >= 1:
                    if new_line_count >= max_char_length - 1:
                        if string[string_offset] == ' ' and string_length - string_offset > 10:
                            break_line_dict.append (new_line_start + new_line_count)
                            new_line_start = new_line_start + new_line_count
                            new_line_count = 0
                            found_space_char = True
                        elif string_offset == string_length - 1 and found_space_char == False:
                            break_line_dict.append (0)
                    if string[string_offset - 1] == '\\' and string[string_offset] == 'n':
                        break_line_dict.append (string_offset + 1)
                        new_line_start = string_offset + 1
                        new_line_count = 0
                string_offset += 1
                new_line_count += 1
            if break_line_dict != []:
                break_line_dict.sort ()
                for each in break_line_dict:
                    if each > 0:
                        multilines += "  %s\n" % string[current_string_start:each].lstrip()
                    current_string_start = each
                if string_length - current_string_start > 0:
                    multilines += "  %s\n" % string[current_string_start:].lstrip()
        return multilines


    def load_xml (self, cfg_file):
        self.initialize ()
        # TODO: Remove hard coded path
        xsd = xmlschema.XMLSchema('SetupDataPkg/Tools/configschema.xsd')
        if not xsd.is_valid(cfg_file):
            raise Exception ("Input xml does not meet corresponding schema")
        # with open (cfg_file, 'rb') as file:
        #     self._cfg_tree = xmltodict.parse(file)
        #     print (self._cfg_tree)
        tree = ET.parse (cfg_file)
        self.root = tree.getroot()
        for node in self.root:
            print (node)
            if node.tag in CGenNCCfgData.config_list:
                # really process the fields
                print (node.tag)
        # self.build_cfg_list()
        # self.build_var_dict()
        # self.update_def_value()
        return 0


def usage():
    print ('\n'.join([
          "GenNCCfgData Version 0.1",
          "Usage:",
          "    GenNCCfgData  GENBIN  XmlFile[;DltFile]   BinOutFile",
          "    GenNCCfgData  GENDLT  XmlFile[;BinFile]   DltOutFile"
          ]))


def main():
    # Parse the options and args
    argc = len(sys.argv)
    if argc < 4 or argc > 5:
        usage()
        return 1

    gen_cfg_data = CGenNCCfgData()
    command   = sys.argv[1].upper()
    out_file  = sys.argv[3]

    file_list  = sys.argv[2].split(';')
    if len(file_list) >= 2:
        xml_file   = file_list[0]
        dlt_file   = file_list[1]
    elif len(file_list) == 1:
        xml_file   = file_list[0]
        dlt_file   = ''
    else:
        raise Exception ("ERROR: Invalid parameter '%s' !" % sys.argv[2])

    if command == "GENDLT" and xml_file.endswith('.dlt'):
        # It needs to expand an existing DLT file
        dlt_file = xml_file
        lines  = gen_cfg_data.expand_include_files (dlt_file)
        write_lines (lines, out_file)
        return 0

    cfg_bin_file  = ''
    cfg_bin_file2 = ''
    if dlt_file:
        if command == "GENDLT":
            cfg_bin_file = dlt_file
            dlt_file  = ''
            if len(file_list) >= 3:
                cfg_bin_file2 = file_list[2]

    if xml_file.lower().endswith('.pkl'):
        with open(xml_file, "rb") as pkl_file:
            gen_cfg_data.__dict__ = marshal.load(pkl_file)
        gen_cfg_data.prepare_marshal (False)
    else:
        gen_cfg_data.load_xml (xml_file)

    if dlt_file:
        gen_cfg_data.override_default_value(dlt_file)

    if   command == "GENBIN":
        if len(file_list) == 3:
            old_data = gen_cfg_data.generate_binary_array()
            fi   = open (file_list[2], 'rb')
            new_data = bytearray (fi.read ())
            fi.close ()
            if len(new_data) != len(old_data):
                raise Exception ("Binary file '%s' length does not match, ignored !" % file_list[2])
            else:
                gen_cfg_data.load_default_from_bin (new_data)
                gen_cfg_data.override_default_value(dlt_file)

        gen_cfg_data.generate_binary(out_file)

    elif command == "GENDLT":
        gen_cfg_data.generate_delta_file (out_file, cfg_bin_file, cfg_bin_file2)

    elif command == "DEBUG":
        gen_cfg_data.print_cfgs()

    else:
        raise Exception ("Unsuported command '%s' !" % command)

    return 0


if __name__ == '__main__':
    sys.exit(main())

